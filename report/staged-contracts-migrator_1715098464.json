[
    {
        "kind": "contract-update-failure",
        "account_address": "0xf8d6e0586b0a20c7",
        "contract_name": "HybridCustody",
        "error": "error: mismatching field `factory` in `ChildAccount`\n   --> f8d6e0586b0a20c7.HybridCustody:532:34\n    |\n532 |         access(self) var factory: Capability<&{CapabilityFactory.Getter}>\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ incompatible type annotations. expected `CapabilityFactory.Manager`, found `{CapabilityFactory.Getter}`\n\nerror: mismatching field `delegator` in `ChildAccount`\n   --> f8d6e0586b0a20c7.HybridCustody:544:36\n    |\n544 |         access(self) let delegator: Capability<auth(CapabilityDelegator.Get) &{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ incompatible type annotations. expected `CapabilityDelegator.Delegator`, found `{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}`\n"
    },
    {
        "kind": "contract-update-failure",
        "account_address": "0xf8d6e0586b0a20c7",
        "contract_name": "CapabilityFactory",
        "error": "error: unsafe access modifiers on CapabilityFactory.Manager: the entitlements migration would grant references to this type CapabilityFactory.Owner, CapabilityFactory.Add, CapabilityFactory.Delete authorization, which is too permissive.\n  --> f8d6e0586b0a20c7.CapabilityFactory:42:4\n   |\n42 |     access(all) resource Manager: Getter {\n43 |         /// Mapping of Factories indexed on Type of Capability they retrieve\n44 |         access(all) let factories: {Type: {CapabilityFactory.Factory}}\n45 | \n46 |         /// Retrieves a list of Types supported by contained Factories\n47 |         ///\n48 |         /// @return List of Types supported by the Manager\n49 |         ///\n50 |         access(all) view fun getSupportedTypes(): [Type] {\n51 |             return self.factories.keys\n52 |         }\n53 | \n54 |         /// Retrieves a Factory from the Manager, returning it or nil if it doesn't exist\n55 |         ///\n56 |         /// @param t: Type the Factory is indexed on\n57 |         ///\n58 |         access(all) view fun getFactory(_ t: Type): {CapabilityFactory.Factory}? {\n59 |             return self.factories[t]\n60 |         }\n61 | \n62 |         /// Adds a Factory to the Manager, conditioned on the Factory not already existing\n63 |         ///\n64 |         /// @param t: Type of Capability the Factory retrieves\n65 |         /// @param f: Factory to add\n66 |         ///\n67 |         access(Owner | Add) fun addFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {\n68 |             pre {\n69 |                 !self.factories.containsKey(t): \"Factory of given type already exists\"\n70 |             }\n71 |             self.factories[t] = f\n72 |         }\n73 | \n74 |         /// Updates a Factory in the Manager, adding if it didn't already exist\n75 |         ///\n76 |         /// @param t: Type of Capability the Factory retrieves\n77 |         /// @param f: Factory to replace existing Factory\n78 |         ///\n79 |         access(Owner | Add) fun updateFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {\n80 |             self.factories[t] = f\n81 |         }\n82 | \n83 |         /// Removes a Factory from the Manager, returning it or nil if it didn't exist\n84 |         ///\n85 |         /// @param t: Type the Factory is indexed on\n86 |         ///\n87 |         access(Owner | Delete) fun removeFactory(_ t: Type): {CapabilityFactory.Factory}? {\n88 |             return self.factories.remove(key: t)\n89 |         }\n90 | \n91 |         init () {\n92 |             self.factories = {}\n93 |         }\n94 |     }\n   |     ^ Consider removing any disjunction access modifiers\n"
    },
    {
        "kind": "contract-update-failure",
        "account_address": "0xf8d6e0586b0a20c7",
        "contract_name": "CapabilityFilter",
        "error": "error: unsafe access modifiers on CapabilityFilter.DenylistFilter: the entitlements migration would grant references to this type CapabilityFilter.Owner, CapabilityFilter.Add, CapabilityFilter.Delete authorization, which is too permissive.\n  --> f8d6e0586b0a20c7.CapabilityFilter:34:4\n   |\n34 |     access(all) resource DenylistFilter: Filter {\n35 | \n36 |         /// Represents the underlying types which should not ever be returned by a RestrictedChildAccount. The filter\n37 |         /// will borrow a requested capability, and make sure that the type it gets back is not in the list of denied\n38 |         /// types\n39 |         access(self) let deniedTypes: {Type: Bool}\n40 | \n41 |         /// Adds a type to the mapping of denied types with a value of true\n42 |         /// \n43 |         /// @param type: The type to add to the denied types mapping\n44 |         ///\n45 |         access(Owner | Add) fun addType(_ type: Type) {\n46 |             self.deniedTypes.insert(key: type, true)\n47 |             emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)\n48 |         }\n49 | \n50 |         /// Removes a type from the mapping of denied types\n51 |         ///\n52 |         /// @param type: The type to remove from the denied types mapping\n53 |         ///\n54 |         access(Owner | Delete) fun removeType(_ type: Type) {\n55 |             if let removed = self.deniedTypes.remove(key: type) {\n56 |                 emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)\n57 |             }\n58 |         }\n59 | \n60 |         /// Removes all types from the mapping of denied types\n61 |         ///\n62 |         access(Owner | Delete) fun removeAllTypes() {\n63 |             for type in self.deniedTypes.keys {\n64 |                 self.removeType(type)\n65 |             }\n66 |         }\n67 | \n68 |         /// Determines if a requested capability is allowed by this `Filter`\n69 |         ///\n70 |         /// @param cap: The capability to check\n71 |         /// @return: true if the capability is allowed, false otherwise\n72 |         ///\n73 |         access(all) view fun allowed(cap: Capability): Bool {\n74 |             if let item = cap.borrow<&AnyResource>() {\n75 |                 return !self.deniedTypes.containsKey(item.getType())\n76 |             }\n77 | \n78 |             return false\n79 |         }\n80 | \n81 |         /// Returns details about this filter\n82 |         ///\n83 |         /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`\n84 |         ///         key as well as types denied indexed on the `deniedTypes` key\n85 |         ///\n86 |         access(all) view fun getDetails(): AnyStruct {\n87 |             return {\n88 |                 \"type\": self.getType(),\n89 |                 \"deniedTypes\": self.deniedTypes.keys\n90 |             }\n91 |         }\n92 | \n93 |         init() {\n94 |             self.deniedTypes = {}\n95 |         }\n96 |     }\n   |     ^ Consider removing any disjunction access modifiers\n\nerror: unsafe access modifiers on CapabilityFilter.AllowlistFilter: the entitlements migration would grant references to this type CapabilityFilter.Owner, CapabilityFilter.Add, CapabilityFilter.Delete authorization, which is too permissive.\n   --> f8d6e0586b0a20c7.CapabilityFilter:100:4\n    |\n100 |     access(all) resource AllowlistFilter: Filter {\n101 |         // allowedTypes\n102 |         // Represents the set of underlying types which are allowed to be \n103 |         // returned by a RestrictedChildAccount. The filter will borrow\n104 |         // a requested capability, and make sure that the type it gets back is\n105 |         // in the list of allowed types\n106 |         access(self) let allowedTypes: {Type: Bool}\n107 | \n108 |         /// Adds a type to the mapping of allowed types with a value of true\n109 |         /// \n110 |         /// @param type: The type to add to the allowed types mapping\n111 |         ///\n112 |         access(Owner | Add) fun addType(_ type: Type) {\n113 |             self.allowedTypes.insert(key: type, true)\n114 |             emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)\n115 |         }\n116 | \n117 |         /// Removes a type from the mapping of allowed types\n118 |         ///\n119 |         /// @param type: The type to remove from the denied types mapping\n120 |         ///\n121 |         access(Owner | Delete) fun removeType(_ type: Type) {\n122 |             if let removed = self.allowedTypes.remove(key: type) {\n123 |                 emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)\n124 |             }\n125 |         }\n126 | \n127 |         /// Removes all types from the mapping of denied types\n128 |         ///\n129 |         access(Owner | Delete) fun removeAllTypes() {\n130 |             for type in self.allowedTypes.keys {\n131 |                 self.removeType(type)\n132 |             }\n133 |         }\n134 |         \n135 |         /// Determines if a requested capability is allowed by this `Filter`\n136 |         ///\n137 |         /// @param cap: The capability to check\n138 |         /// @return: true if the capability is allowed, false otherwise\n139 |         ///\n140 |         access(all) view fun allowed(cap: Capability): Bool {\n141 |             if let item = cap.borrow<&AnyResource>() {\n142 |                 return self.allowedTypes.containsKey(item.getType())\n143 |             }\n144 | \n145 |             return false\n146 |         }\n147 | \n148 |         /// Returns details about this filter\n149 |         ///\n150 |         /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`\n151 |         ///         key as well as types allowed indexed on the `allowedTypes` key\n152 |         ///\n153 |         access(all) view fun getDetails(): AnyStruct {\n154 |             return {\n155 |                 \"type\": self.getType(),\n156 |                 \"allowedTypes\": self.allowedTypes.keys\n157 |             }\n158 |         }\n159 | \n160 |         init() {\n161 |             self.allowedTypes = {}\n162 |         }\n163 |     }\n    |     ^ Consider removing any disjunction access modifiers\n"
    },
    {
        "kind": "contract-update-failure",
        "account_address": "0xf8d6e0586b0a20c7",
        "contract_name": "CapabilityDelegator",
        "error": "error: unsafe access modifiers on CapabilityDelegator.Delegator: the entitlements migration would grant references to this type CapabilityDelegator.Get, CapabilityDelegator.Owner, CapabilityDelegator.Add, CapabilityDelegator.Delete authorization, which is too permissive.\n   --> f8d6e0586b0a20c7.CapabilityDelegator:55:4\n    |\n 55 |     access(all) resource Delegator: GetterPublic, GetterPrivate {\n 56 |         access(self) let privateCapabilities: {Type: Capability}\n 57 |         access(self) let publicCapabilities: {Type: Capability}\n 58 | \n 59 |         // ------ Begin Getter methods\n 60 |         //\n 61 |         /// Returns the public Capability of the given Type if it exists\n 62 |         ///\n 63 |         access(all) view fun getPublicCapability(_ type: Type): Capability? {\n 64 |             return self.publicCapabilities[type]\n 65 |         }\n 66 | \n 67 |         /// Returns the private Capability of the given Type if it exists\n 68 |         ///\n 69 |         ///\n 70 |         /// @param type: Type of the Capability to retrieve\n 71 |         /// @return Capability of the given Type if it exists, nil otherwise\n 72 |         ///\n 73 |         access(Get) view fun getPrivateCapability(_ type: Type): Capability? {\n 74 |             return self.privateCapabilities[type]\n 75 |         }\n 76 | \n 77 |         /// Returns all public Capabilities\n 78 |         ///\n 79 |         /// @return List of all public Capabilities\n 80 |         ///\n 81 |         access(all) view fun getAllPublic(): [Capability] {\n 82 |             return self.publicCapabilities.values\n 83 |         }\n 84 | \n 85 |         /// Returns all private Capabilities\n 86 |         ///\n 87 |         /// @return List of all private Capabilities\n 88 |         ///\n 89 |         access(Get) fun getAllPrivate(): [Capability] {\n 90 |             return self.privateCapabilities.values\n 91 |         }\n 92 | \n 93 |         /// Returns the first public Type that is a subtype of the given Type\n 94 |         ///\n 95 |         /// @param type: Type to check for subtypes\n 96 |         /// @return First public Type that is a subtype of the given Type, nil otherwise\n 97 |         ///\n 98 |         access(all) view fun findFirstPublicType(_ type: Type): Type? {\n 99 |             for t in self.publicCapabilities.keys {\n100 |                 if t.isSubtype(of: type) {\n101 |                     return t\n102 |                 }\n103 |             }\n104 | \n105 |             return nil\n106 |         }\n107 | \n108 |         /// Returns the first private Type that is a subtype of the given Type\n109 |         ///\n110 |         /// @param type: Type to check for subtypes\n111 |         /// @return First private Type that is a subtype of the given Type, nil otherwise\n112 |         ///\n113 |         access(all) view fun findFirstPrivateType(_ type: Type): Type? {\n114 |             for t in self.privateCapabilities.keys {\n115 |                 if t.isSubtype(of: type) {\n116 |                     return t\n117 |                 }\n118 |             }\n119 | \n120 |             return nil\n121 |         }\n122 |         // ------- End Getter methods\n123 | \n124 |         /// Adds a Capability to the Delegator\n125 |         ///\n126 |         /// @param cap: Capability to add\n127 |         /// @param isPublic: Whether the Capability should be public or private\n128 |         ///\n129 |         access(Owner | Add) fun addCapability(cap: Capability, isPublic: Bool) {\n130 |             pre {\n131 |                 cap.check<&AnyResource>(): \"Invalid Capability provided\"\n132 |             }\n133 |             if isPublic {\n134 |                 self.publicCapabilities.insert(key: cap.getType(), cap)\n135 |             } else {\n136 |                 self.privateCapabilities.insert(key: cap.getType(), cap)\n137 |             }\n138 |             emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: isPublic, active: true)\n139 |         }\n140 | \n141 |         /// Removes a Capability from the Delegator\n142 |         ///\n143 |         /// @param cap: Capability to remove\n144 |         ///\n145 |         access(Owner | Delete) fun removeCapability(cap: Capability) {\n146 |             if let removedPublic = self.publicCapabilities.remove(key: cap.getType()) {\n147 |                 emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: true, active: false)\n148 |             }\n149 |             \n150 |             if let removedPrivate = self.privateCapabilities.remove(key: cap.getType()) {\n151 |                 emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: false, active: false)\n152 |             }\n153 |         }\n154 | \n155 |         init() {\n156 |             self.privateCapabilities = {}\n157 |             self.publicCapabilities = {}\n158 |         }\n159 |     }\n    |     ^ Consider removing any disjunction access modifiers\n"
    }
]